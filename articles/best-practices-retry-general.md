<properties
   pageTitle="Prøv igen generelle retningslinjer | Microsoft Azure"
   description="Vejledning i forsøg for håndtering af midlertidige fejl."
   services=""
   documentationCenter="na"
   authors="dragon119"
   manager="christb"
   editor=""
   tags=""/>

<tags
   ms.service="best-practice"
   ms.devlang="na"
   ms.topic="article"
   ms.tgt_pltfrm="na"
   ms.workload="na"
   ms.date="07/13/2016"
   ms.author="masashin"/>

# <a name="retry-general-guidance"></a>Prøv igen generelle retningslinjer

[AZURE.INCLUDE [pnp-header](../includes/guidance-pnp-header-include.md)]

## <a name="overview"></a>Oversigt

Alle programmer, kommunikerer med eksterne tjenester og ressourcer skal være følsomme til midlertidige fejl. Dette er især tilfældet for programmer, der kører i skyen, hvor art-miljø og forbindelse via internettet betyder, at disse typer fejl kan opstå oftere. Midlertidige fejl omfatter midlertidige tab af netværksforbindelse til komponenter og -tjenester, midlertidige hvorfor en tjeneste eller timeout, der opstår, når en tjeneste er optaget. Disse fejl er ofte selv korrigerende, og hvis handlingen gentages efter en passende forsinkelse er det sandsynligvis lykkes.

Dette dokument omhandler generelle retningslinjer for håndtering af midlertidige fejl. Finde oplysninger om håndtering af midlertidige fejl, når du bruger Microsoft Azure-tjenester, [Azure service-specifikke prøv igen retningslinjer](best-practices-retry-service-specific.md).

## <a name="why-do-transient-faults-occur-in-the-cloud"></a>Hvorfor midlertidige fejl opstår i skyen?

Midlertidige fejl kan opstå i et miljø, på en hvilken som helst platform eller operativsystem og i enhver type af programmet. I løsninger placeret, kører lokale, lokale infrastruktur, ydeevnen og tilgængeligheden af programmet og dets komponenter er typisk føres gennem dyr og under tit hardware redundans og komponenter og ressourcer er tæt på hver en anden. Mens dette opretter en mislykket mindre sandsynligt, kan det stadig resultere i midlertidige fejl – og endda en afbrydelse gennem uventede begivenheder som eksterne power levering eller netværksproblemer eller andre nedbrud scenarier.

Vært for skyen, herunder private skyen systemer kan tilbyde en højere overordnede tilgængelighed ved hjælp af delte ressourcer, redundans, automatisk failover og dynamisk ressourceallokering på tværs af et stort antal vare Beregn noder. Hvilke disse miljøer kan dog betyder der optræder oftest midlertidige fejl. Der er flere årsager til dette:

* Mange ressourcer i et skybaseret miljø er delt, og adgang til disse ressourcer er underlagt (throttling) for at beskytte ressourcen. Nogle af tjenesterne nægte forbindelser, når afkrydsningsfeltet Indlæs stiger til et bestemt niveau, eller en maksimale overførselshastighed er nået, for at tillade behandling af eksisterende anmodninger og til at bevare ydeevnen af tjenesten for alle brugere. Begrænsning hjælper med at bevare kvaliteten af tjenesten til tilstødende netværk og andre lejere, ved hjælp af den delte ressource.
* Skyen miljøer er bygget til brug af store tal på vare hardware enheder. De levere ydeevne ved at distribuere dynamisk belastning på tværs af flere databehandling enheder og infrastrukturkomponenter, og Levér pålidelighed ved automatisk genbrug eller udskifte mislykkedes enheder. Denne dynamiske art betyder, midlertidige fejl og midlertidig forbindelse fejl kan opstå nogle gange.
* Der er ofte flere hardwarekomponenter, herunder netværksinfrastruktur som en router og Indlæs balancere, mellem programmet og de ressourcer og -tjenester, der bruges. Denne ekstra infrastruktur kan undertiden introducere ekstra internetforbindelse ventetid og midlertidige forbindelse fejl.
* Netværk betingelser mellem klienten og serveren muligvis variabel, især hvis kommunikation krydser internettet. Selv i lokale placeringer meget tungt trafik indlæse sænke kommunikation og medføre vekslende forbindelse fejl.

## <a name="challenges"></a>Udfordringer
Midlertidige fejl kan have stor indflydelse på anslåede tilgængeligheden af et program, selvom den er grundigt testet under alle forudsigelige omstændigheder. For at sikre, skyen hostet programmer betjene pålideligt, skal de kunne svare på de udfordringer, som følgende:

* Programmet skal være i stand til at registrere fejl, når de opstår, og at fastlægge, om der sandsynligvis er midlertidige, mere lang tid efter disse fejl, eller er terminal mislykkede forsøg. Forskellige ressourcer er sandsynligvis til at returnere forskellige svar, når en fejl opstår, og disse svar også kan variere afhængigt af konteksten af handlingen. svar til en fejl, når du læser fra lagerplads kan for eksempel være forskellige fra svar til en fejl, når du skriver til lager. Mange ressourcer og tjenester har ordentligt dokumenterede midlertidige fejl kontrakter. Men, hvor disse oplysninger ikke er tilgængelig, skal det være svær at finde fejlen, og om det er sandsynligvis er midlertidige art.
* Programmet skal kunne prøv igen, hvis det registreres, at fejlen, der sandsynligvis vil være midlertidige og holde styr på antallet gange handlingen blev forsøgt igen.
* Programmet skal bruge en passende strategi for gentagelserne. Denne strategi angiver antallet gange, den skal prøve igen, skal forsinkelsen mellem hvert forsøg og handlingerne til at tage efter en mislykkede forsøg på. Det ønskede antal forsøg og forsinkelse mellem hver af dem, er ofte svært at bestemme, og varierer afhængigt af typen ressource samt betingelser for de aktuelle driften af ressourcen og selve programmet.

## <a name="general-guidelines"></a>Generelle retningslinjer
Følgende retningslinjer hjælper dig med at designe en passende midlertidige fejl aflevering ordning til dine programmer:

* **Afgøre, om der er en indbygget forsøg ordning:**
  * Mange tjenester giver en SDK-klient eller bibliotek, der indeholder en midlertidig fejl håndtering af funktion. Politikken retry bruges typisk er skræddersyet til art og krav til destinationsadresse-tjenesten. RESTEN grænseflader til services kan også returnere oplysninger, der er nyttige ved fastlæggelse af, om et nyt forsøg er relevante, og hvor lang tid skal gå, før den næste forsøg på at.
  * Brug den indbyggede forsøg ordning, hvor en er tilgængelig, medmindre du har bestemt og grundigt forstået krav, der betyder flere forskellige forsøg funktioner er mere passende.
* **Ud af, om handlingen egner sig til prøver igen**:
  * Du skal kun gentagne handlinger, hvor fejlene er forbigående (typisk angivet med fejlens karakter), og hvis der er mindst nogle sandsynligheden for, at handlingen lykkes, når reattempted. Der er ingen grund mellem handlinger, som angiver en ugyldig handling som en database opdatering til et element, der ikke findes, eller anmodninger om til en tjeneste eller en ressource, der har lidt en alvorlige fejl
  * Du skal generelt implementere forsøg kun hvor fuld påvirkningen af dette kan bestemmes, og betingelserne, der er forstået og kan valideres. Hvis ikke, lade det til at implementere forsøg opkald koden. Husk, fejlene returneres fra ressourcer og tjenester uden for dit kontrolelement kan udvikle sig over en periode, og du kan være nødvendigt at besøge igen dine midlertidige fejl registreringslogik.
  * Når du opretter services eller komponenter, kan du overveje at implementere fejlkoder og meddelelser, der kan hjælpe kunder finde ud af, om de skal prøve mislykkede handlinger. Angiv, især hvis klienten skal prøve igen (måske ved at returnere en **isTransient** værdi) og foreslå et passende forsinkelse, før den næste forsøg på at. Hvis du opretter en webtjeneste, kan du overveje at returnere brugerdefinerede fejl, der er defineret i tjenesten kontrakterne. Selvom generisk klienter ikke muligvis kunne læse disse, vil de være nyttige, når du opretter brugerdefinerede klienter.
* **Find ud af et antal relevante forsøg og interval:**
  * Det er vigtigt at optimere antal forsøg og intervallet til typen af use case. Hvis du ikke igen et tilstrækkeligt antal gange, programmet vil ikke kunne udføre denne handling og er sandsynligvis opleve en fejl. Hvis du prøv igen for mange gange, eller med for kort et interval mellem forsøger, programmet rumme potentielt ressourcer som tråde, forbindelser og hukommelse lange perioder, der kan påvirke tilstanden af programmet.
  * De relevante værdier for et tidsinterval og antallet af forsøg forsøg afhænger af typen af blive forsøgt handling. Eksempelvis hvis handlingen er en del af en brugerinteraktion, intervallet, der skal være korte og kun et par forsøg forsøgte at undgå at foretage brugere, der venter på svar (som indeholder åbne forbindelser og kan reducere tilgængelighed for andre brugere). Hvis handlingen er en del af en lang tid, der kører eller kritiske arbejdsproces, hvor annullering og genstarte processen er dyr eller mere tidskrævende, er det relevant at vente længere mellem forsøg, og prøv igen flere gange.
  * Fastslå de passende mellemrum mellem nye forsøg er den mest svært del med at designe en vellykket strategi. Typisk strategier Brug følgende typer interval for gentagelse:
      * **Eksponentialfunktionen tilbage fra**. Programmet skal vente et øjeblik, før den første gentagelse og derefter eksponentielt øge gange mellem hver efterfølgende forsøg igen. Det kan for eksempel prøv igen efter 3 sekunder 12 sekunder, 30 sekunder, og så videre.
      * **Trinvise intervaller**. Programmet skal vente et øjeblik, før den første gentagelse og derefter stigende gange mellem hver efterfølgende forsøg igen. Det kan for eksempel prøv igen efter 3 sekunder, 7 sekunder, 13 sekunder, og så videre.
      * **Jævne mellemrum**. Programmet venter på den samme periode mellem hvert forsøg på. Det kan for eksempel en intern fejl hver 3 sekunder.
      * **Immediate prøv igen**. Nogle gange er en midlertidig fejl meget korte måske skyldes en begivenhed som en netværk pakke konflikt eller en samling i en hardwarekomponent. I dette tilfælde er prøver igen med det samme relevante fordi den kan fuldføres, hvis fejlen er ryddet i den tid, det tager programmet til at samle og sende den næste anmodning. Dog der bør aldrig være mere end én øjeblikkelig forsøg på at, og du skal skifte til alternative strategier, f.eks som eksponentiel back-fra eller fallback handlinger, hvis vil øjeblikkelig afsendelsen mislykkes.
      * **Randomisering**. En af vil afsendelsen strategier er anført ovenfor kan omfatte en randomisering for at forhindre flere forekomster af klienten sender efterfølgende forsøg forsøg på samme tid. For eksempel én forekomst kan prøve igen efter 3 sekunder, 11 sekunder, 28 sekunder og osv., mens en anden forekomst kan udføres efter 4 sekunder 12 sekunder, 26 sekunder, og så videre. Randomisering er en praktisk metode, der kan kombineres med andre strategier.  
  * Bruge en eksponentiel tilbage fra strategi for handlinger i baggrunden og øjeblikkelig eller regelmæssige interval forsøg strategier til interaktive handlinger, som en generel vejledning. I begge tilfælde skal du vælge forsinkelsen og antal forsøg, så den maksimale ventetid for alle gentagne forsøg er i påkrævet til slut ventetid kravet.
  * Tage hensyn til kombinationen af alle de faktorer, der bidrager til den overordnede maksimale timeout for en handling af forsøgt igen. Disse faktorer omfatter den tid, det tager for en mislykket forbindelse til at oprette et svar (der typisk angives ved en timeoutværdien i klienten) samt forsinkelse mellem forsøg forsøg og det maksimale antal gentagne forsøg. Summen af alle disse gange kan medføre meget store overordnede handlingen tidspunkter, især når ved hjælp af en eksponentiel forsinkelse strategi for, hvor intervallet mellem nye forsøg vokser hurtigt efter hver fejl. Hvis en proces skal opfylde et bestemt niveau serviceaftale (SLA), skal den samlede tid i handlingen, herunder alle timeout og forsinkelser, være i, som defineret i SERVICEAFTALEN
  * Over-aggressive forsøg strategier, der er for kort intervaller eller også kan nye forsøg, kan have en negativ effekt på target ressource eller tjeneste. Dette kan forhindre ressource eller tjeneste i gendanne fra dens overloadede tilstand, og fortsætter med at blokere eller afviser anmodninger. Denne resultaterne i en vicious cirkel, hvor flere og flere anmodninger sendes til ressourcen eller tjeneste, og derfor muligheden for at gendanne reduceres yderligere.
  * Tage, hensyn timeout handlinger, når du vælger intervallerne forsøg igen for at undgå at åbne en efterfølgende forsøg med det samme (for eksempel, hvis timeout-perioden svarer til intervallet for gentagelse). Overvej også, hvis du vil bevare den samlede mulige varighed (timeouten plus retry-intervallerne) til under en bestemt Samlet tid. Handlinger, som har meget kort eller lang timeout kan påvirke hvor lang tid at Vent, og hvor ofte der skal udføres.
  * Brug typen undtagelsen, og alle data, den indeholder, eller de fejlkoder og -meddelelser, der returneres fra tjenesten, du kan optimere intervallet og antallet af forsøg. For eksempel, nogle undtagelser eller fejl koder (f.eks HTTP kode 503 Tjenesten er utilgængelig med en forsøg igen efter overskrift i svaret) kan angiver, hvor lang tid fejlen kan varer eller, tjenesten mislykkes og reagerer ikke på alle efterfølgende forsøg.
* **Undgå mod mønstre**:
  * I de fleste tilfælde, skal du undgå installationer, som omfatter dublerede lag af forsøg kode. Undgå design, der omfatter overlappende forsøg mekanismer eller, implementere forsøg på hvert enkelt trin af en handling, der involverer et hierarki af anmodninger, medmindre du har særlige krav, som kræver dette. Brug politikker, der forhindrer unødvendig antal forsøg og forsinkelse perioder, og Sørg for, at du forstår konsekvenserne i disse særlige tilfælde. Hvis en komponent opretter en anmodning til en anden, forsøger hvilke derefter adgang tjenesten destination, og du implementere forsøg igen med en optælling af tre på begge opkald, der vil være ni prøv igen for eksempel i total mod tjenesten. Mange tjenester og ressourcer implementere en indbygget forsøg ordning og bør du undersøge, hvordan du kan deaktivere eller ændre dette, hvis du har brug at implementere forsøg på et højere niveau.
  *  Aldrig implementere en uendelig forsøg metode. Dette er sandsynligvis forhindre ressourcen eller gendanne fra overbelastning situationer-tjenesten og medføre (throttling) og afviste forbindelser fortsat for en længere periode. Brug af en endelig tal eller forsøg, eller implementere et mønster som [afbryder](http://msdn.microsoft.com/library/dn589784.aspx) tillade tjenesten til at gendanne.
  * Udføre aldrig en øjeblikkelig forsøg mere end én gang.
  * Undgå at bruge et interval for almindelige gentagelse, især hvis du har et stort antal forsøg på Prøv igen, når du åbner tjenester og ressourcer i Azure. Den optimale tilgang er dette scenario er en eksponentiel tilbage fra strategi for med en kredsløb seneste egenskab.
  * Forhindre, at flere forekomster af den samme klient eller flere forekomster af forskellige klienter, fra at sende nye forsøg på samme tid. Hvis dette er kan opstå, introduceres randomisering i retry-intervaller.
* **Teste din strategi for prøv igen og implementering:**
  * Kontrollér, at du fuldt teste forsøg strategi implementeringen under som bredt et sæt af omstændigheder som muligt, især hvis både programmet og mål ressourcer eller services bruges er meget belastning. Hvis du vil kontrollere funktionsmåde under testen, kan du:
      * Indsæt midlertidige og permanent fejl i tjenesten. For eksempel sende ugyldige anmodninger eller tilføje kode, der registrerer test anmoder om og reagerer med forskellige typer fejl. Et eksempel bruger TestApi, se [Fejl indsættelse test med TestApi](http://msdn.microsoft.com/magazine/ff898404.aspx) og [Introduktion til TestApi – del 5: administreret kode fejl indsættelse API'er](http://blogs.msdn.com/b/ivo_manolov/archive/2009/11/25/9928447.aspx).
      * Oprette en mock for ressourcen eller tjeneste, der returnerer en række fejl, som kan returnere tjenesten reelt tal. Sikre, at du dækker alle typerne fejl, som din strategi for forsøg er designet til at registrere.
      * Tving midlertidige fejl ved at deaktivere eller overbelastning tjenesten, hvis det er en brugerdefineret tjeneste, som du har oprettet og installeret midlertidigt (du skal ikke, naturligvis forsøge at overbelastning delte ressourcer eller delte tjenester i Azure).
      * Overvej at bruge biblioteket FiddlerCore i din automatiseret test til at ændre med resultatet af HTTP-anmodninger, ved at tilføje ekstra RTT gange eller ved at ændre svaret (såsom HTTP-statuskode, sidehoveder, brødtekst eller andre faktorer) til HTTP-baseret API'er. Den måde kan deterministisk test af et undersæt af betingelser fejl om midlertidige fejl eller andre typer fejl. Du kan finde flere oplysninger [FiddlerCore](http://www.telerik.com/fiddler/fiddlercore). Eksempler på, hvordan du bruger biblioteket, særligt **HttpMangler** klassen, undersøge [kildekode til Azure lagerplads SDK](https://github.com/Azure/azure-storage-net/tree/master/Test).
      * Udføre høj belastning faktor og samtidige forsøg for at sikre, at forsøg ordning og strategi fungerer korrekt under disse omstændigheder og ikke har en negativ effekt på driften af klienten eller medføre krydsforurening mellem anmodninger.
* **Administrere forsøg politik konfigurationer:**
  * En _prøve politik_ er en kombination af alle elementer af din strategi for prøv igen. Den definerer den registrering metode, bestemmer, om en fejl, der sandsynligvis er forbigående, hvilken type interval bruge (som normalt, eksponentiel back-fra, og randomisering), faktisk interval værdierne, og antallet gange til at prøve igen.
  * Nye forsøg skal implementeres på mange forskellige steder i det nemmeste program og i alle lag med mere komplekse programmer. I stedet for hårde-kodning elementerne i hver politik på flere placeringer, kan du overveje at bruge et centralt punkt til lagring af alle politikkerne. For eksempel gemme værdier som intervallet og antal i konfiguration programfiler forsøg, læse dem på kørselstidspunktet og automatisk oprette politikkerne, der prøv igen. Det gør det nemmere at administrere indstillingerne, og for at redigere og finjustere værdierne for at besvare ændre krav og scenarier. Designe dog systemet til at gemme værdierne i stedet for rereading en konfiguration fil hver gang, og sikre passende standardværdierne bruges, hvis værdierne, der ikke kunne hentes fra konfiguration.
  * I et Azure Cloud Services-program, skal du gemme de værdier, der bruges til at opbygge forsøg politikker på kørselstidspunktet i konfigurationsfil tjenesten, så de kan ændres uden at skulle genstart programmet.
  * Drage fordel af indbyggede eller standard forsøg strategier tilgængelig i klienten API'er, du bruger, men kun hvis de er relevante for det pågældende scenarie. Disse strategier er typisk Generelt. I visse scenarier med de kan være alle, der er påkrævet, men andre scenarier kan de ikke tilbyder alle de indstillinger, så det passer til din specifikke krav. Du skal forstå, hvordan indstillingerne vil påvirke dit program gennem tests til at bestemme de mest relevante værdier.
* **Log og registrere midlertidige og permanent fejl:**
  * Omfatte håndtering af undtagelse og andre funktion, der logger når forsøg forsøges som en del af din strategi for prøv igen. Mens en lejlighedsvise midlertidige fejl, og prøv igen er forventes, og ikke angiver en problemet, normalt og stigende antal forsøg er ofte en indikator om et problem, der kan medføre en fejl eller i øjeblikket, som påvirker beskyttelsen programmet ydeevne og tilgængelighed.
  * Log midlertidige fejl som advarsel poster i stedet for fejlposter, så overvågning systemer ikke registrerer dem som programfejl, der kan udløse falske alarmer.
  * Overvej at gemme en værdi i dine logposter, der angiver, hvis gentagelserne blev skyldes (throttling) i service, eller andre typer fejl som forbindelse fejl, så du kan skelne dem under analyse af data. Et større antal variere den benyttede fejl er ofte en indikator for en design fejl i programmet eller er nødvendigheden at skifte til en premium-tjeneste, der indeholder dedikeret hardware.  
  * Overvej at måle og logføring den samlede tid, det tager for handlinger, der omfatter en forsøg ordning. Dette er en god indikator for den overordnede effekt af midlertidige fejl på bruger svar gange, proces ventetid og effektivitet af programmet use cases. Der opstod også log antallet af forsøg for at forstå de faktorer, der har bidraget til feltet svartid.
  * Overvej at implementere en telemetri og overvågning system, kan udløse en besked, når det nummer og frekvens for fejl, det gennemsnitlige antal forsøg, eller de overordnede tidspunkter taget for handlinger til lykkes, øges.
* **Administrere handlinger, som kontinuerligt mislykkes:**
  * Der vil være omstændigheder, hvor fortsættes handlingen mislykkes på hver forsøg, og det er vigtigt at overveje, hvordan du håndterer problemet:
      * Selvom en strategi for forsøg, der definerer det maksimale antal gange, handlingen skal forsøges, forhindrer det ikke det program, der er gentaget handlingen igen med det samme antal gentagne forsøg. Hvis en rækkefølge, behandlingen af tjenesten mislykkes med en alvorlige fejl, der placerer den af handling permanent, kan forsøg strategi for eksempel registrerer forbindelsestimeout for en og overveje det skal være en midlertidig fejl. Koden vil prøve igen et angivet antal gange, og giv derefter. Men, når en anden kunde placerer en rækkefølge, handlingen vil blive forsøgt igen - selvom det er sikker på, at mislykkes hver gang.
      * Hvis du vil forhindre gentaget nye forsøg for handlinger, som kontinuerligt mislykkes, skal du overvejer at implementere [afbryder mønster](http://msdn.microsoft.com/library/dn589784.aspx). I dette mønster, hvis antallet af mislykkede inden for en bestemt tidsramme overskrider grænsen returneres anmodninger til kalderen med det samme som fejl, uden at forsøge at få adgang til mislykkedes ressource eller tjeneste.
      * Programmet kan med jævne mellemrum teste tjenesten, på grundlag af vekslende og med meget lang intervallerne mellem anmodninger om at registrere, hvornår den bliver tilgængelig. Et passende interval, afhænger af scenariet, som oplysningerne om handlingen og karakteren af tjenesten, og kan være noget mellem et par minutter og flere timer. På det sted, hvor testen, programmet genoptag normal drift og overføre anmodninger til tjenesten nyligt gendannet.
      * I mellemtiden kan være det muligt at gå tilbage til en anden forekomst af tjenesten (måske i en anden datacenter eller et program), bruge en lignende tjeneste, der indeholder kompatible (måske nemmere) funktionalitet eller udføre nogle andre handlinger i håb om, at tjenesten, vil være tilgængelige snart. For eksempel kan det være relevant at gemme anmodninger om tjenesten i en kø eller data gemme og afspille dem senere. Ellers du muligvis ikke kunne omdirigerer brugeren til en anden forekomst af programmet, ydeevnen af programmet, men stadig tilbyde acceptable funktionalitet, eller blot returnerede en meddelelse til den bruger, der angiver, programmet ikke er tilgængelig på Præsenter.

* **Andre overvejelser**
  * Når du bestemmer dig for værdierne for antallet af forsøg og prøv igen intervaller for en politik, kan du overveje Hvis handlingen på den tjeneste eller ressource er en del af en handling af længerevarende eller flere trin. Det kan være svært eller dyrt at kompensation alle de andre funktionsdygtige trin, som har allerede blev opdateret, når en mislykkes. I dette tilfælde en meget lang interval og et stort antal forsøg kan være acceptable så længe den ikke forhindrer andre handlinger ved at holde eller låse knappe ressourcer.
  * Overvej, hvis prøver samme igen kan forårsage uoverensstemmelser i data. Hvis nogle dele af en proces med flere trin gentages, og handlingerne er ikke idempotent, kan det resultere i en uoverensstemmelse. For eksempel en handling, der øger en værdi, hvis gentaget, giver en ugyldig resultat. Gentage en handling, der sender en meddelelse til en kø kan medføre en uoverensstemmelse i den meddelelse forbruger Hvis det ikke kan finde dublerede meddelelser. For at undgå dette, skal du sikre dig, at du designer hvert trin som handlingen idempotent. Du kan finde flere oplysninger om redundanskontrol, [Redundanskontrol mønstre](http://blog.jonathanoliver.com/2010/04/idempotency-patterns/).
  * Overvej at omfanget af de handlinger, der vil blive forsøgt igen. Det kan for eksempel være nemmere at implementere forsøg kode på et niveau, der omfatter flere handlinger, og prøv igen dem alle, hvis en mislykkes. Dog kan at gøre dette medføre problemer med redundanskontrol eller unødvendige rollback handlinger.
  * Hvis du vælger et forsøg omfang, der omfatter flere handlinger, tage hensyn til den samlede forsinkelse på alle af dem ved bestemmelse af intervaller forsøg igen, når overvågning den tid, og før der opstår beskeder for fejl.
  * Overvej, hvordan din strategi for forsøg kan påvirke tilstødende netværk og andre lejere i et delte program, eller når du bruger delte ressourcer og -tjenester. Tilstanden forsøg politikker kan medføre et stigende antal midlertidige fejl skal udføres for disse andre brugere og programmer, som deler ressourcer og -tjenester. På samme måde, dit program kan påvirkes af de forsøg politikker, der er implementeret fra andre brugere af de ressourcer og -tjenester. For kritiske programmer, kan du beslutter at bruge premium-tjenester, der ikke deles. Dette giver dig bedre kontrol over Indlæs og deraf følgende (throttling) af disse ressourcer og -tjenester, som kan hjælpe med at justere de ekstra omkostninger.

## <a name="more-information"></a>Få mere at vide

* [Prøv igen Azure service-specifikke retningslinjer](best-practices-retry-service-specific.md)
* [Midlertidige fejl håndtering af programmet blokering](http://msdn.microsoft.com/library/hh680934.aspx)
* [Afbryder mønster](http://msdn.microsoft.com/library/dn589784.aspx)
* [Kompensation transaktion mønster](http://msdn.microsoft.com/library/dn589804.aspx)
* [Redundanskontrol mønstre](http://blog.jonathanoliver.com/2010/04/idempotency-patterns/)

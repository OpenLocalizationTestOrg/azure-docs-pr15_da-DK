<properties
   pageTitle="Skalerbarhed tjekliste | Microsoft Azure"
   description="Skalerbarhed tjekliste vejledning til design problemstillinger til Azure Autoskalering."
   services=""
   documentationCenter="na"
   authors="dragon119"
   manager="christb"
   editor=""
   tags=""/>

<tags
   ms.service="best-practice"
   ms.devlang="na"
   ms.topic="article"
   ms.tgt_pltfrm="na"
   ms.workload="na"
   ms.date="07/13/2016"
   ms.author="masashin"/>

# <a name="scalability-checklist"></a>Skalerbarhed tjekliste

[AZURE.INCLUDE [pnp-header](../includes/guidance-pnp-header-include.md)]

## <a name="service-design"></a>Tjenesten design
- **Partition arbejdsbelastningen**. Designe dele af processen skal være dedikeret og decomposable. Minimere størrelsen på hver side, mens du følge de sædvanlige regler til adskillelse af problemstillinger og princippet enkelt ansvar. Dette giver mulighed for komponenterne skal fordeles på en måde, som maksimerer brug af hver Beregn enhed (som en rolle eller database server). Det gør det også nemmere at skalere programmet ved at tilføje forekomster af bestemte ressourcer. Du kan finde yderligere oplysninger finder [Beregne partitionering vejledning](https://msdn.microsoft.com/library/dn589773.aspx).
- **Design til skalering**. Skalering gør det muligt for programmer til at reagere på variable Indlæs ved at øge og reducere antallet af forekomster af roller, kø og andre tjenester, de bruger. Men programmet skal være designet med dette huske. For eksempel skal programmet og de tjenester, der bruges være i en tilstand, så anmodninger skal dirigeres til en hvilken som helst forekomst. Dette forhindrer også tilføjelse eller fjernelse af specifikke forekomster negativt, som påvirker beskyttelsen aktuelle brugere. Du skal også implementere konfiguration eller automatisk registrering af forekomster som de er tilføjet og fjernet, så kode i programmet på computeren kan udføre nødvendige ruten. For eksempel kan et webprogram bruge et sæt af køer i en round robin-procedure til at omdirigere anmodninger til baggrunden services kører i arbejder roller. Webprogrammet skal kunne registrere ændringer i antallet af køer til at sende anmodninger og saldo belastning på programmet korrekt.
- **Skala som en enhed**. Planlægge i forhold til yderligere ressourcer til vækst. Ved øverste skalering begrænsninger for hver ressource, og brug sharding eller opdelingstræ til at overskride disse begrænsninger. Bestemme skala enhederne for systemet med hensyn til klart defineret sæt af ressourcer. Dette gør anvender skala ud handlinger nemmere og mindre giver risiko for negativ indvirkning på programmet via begrænsninger ved manglende ressourcer i en del af det samlede system. For eksempel at tilføje x antal internettet og arbejder roller kan kræve, at y antal yderligere køer og z antallet af lagerplads konti til at håndtere flere arbejdsbelastningen genereres af rollerne. Så en enhed for tidsskala kan bestå af x internettet og arbejder roller, forespørgsler _y_ og _z_ lagerplads konti. Designe programmet, så det er nemt skaleret ved at tilføje en eller flere skalaenheder.
- **Undgå klienten forbindelse**. Hvor det er muligt, kan du sikre dig, at programmet ikke kræver forbindelse. Anmodninger om og som derfor kan også sendes til en hvilken som helst forekomst, og antallet forekomster er irrelevante. Derved undgår også arbejde med at gemme, hente og vedligeholde tilstandsoplysninger for hver bruger.
- **Udnytte platform Autoskalering funktioner**. Hvor hosting platform understøtter mulighed Autoskalering som Azure Autoskalering, skal du foretrækker det til brugerdefineret eller tredjepart netværksadgang, medmindre den indbyggede funktion ikke kan opfylder dine behov. Bruge planlagte skalering regler, hvor muligt at sikre, at ressourcer er tilgængelige opstart for straks, men føje aktiv Autoskalering til reglerne, hvor det er relevant at imødegå uventede ændringer i efter behov. Du kan bruge handlingerne Autoskalering i Service Management API til at justere Autoskalering og føje brugerdefinerede tællere til regler. Du kan finde yderligere oplysninger finder [automatisk skalering vejledning](best-practices-auto-scaling.md).
- **Offload intensivt CPU/EY opgaver som opgaver i baggrunden**. Hvis en anmodning til en tjeneste forventes at tage lang tid at køre eller opfanger betydelige ressourcer, aflaste behandlingen for denne anmodning til en separat opgave. Brug arbejder roller eller baggrundsjob (afhængigt af den hosting platform) til at udføre disse opgaver. Denne strategi aktiverer tjeneste for at fortsætte med at modtage flere anmodninger og forbliver svarede.  Du kan finde yderligere oplysninger finder [baggrund job vejledning](best-practices-background-jobs.md).
- **Fordel arbejdsbelastningen for opgaver i baggrunden**. Hvor der er mange opgaver i baggrunden, eller opgaverne, der kræver lang tid eller ressourcer, fordele arbejdet på tværs af flere Beregn enheder (såsom arbejder roller eller baggrundsjob). Du kan finde en mulig løsning [Konkurrere forbrugere mønster](https://msdn.microsoft.com/library/dn568101.aspx).
- **Overvej at bestræbelserne på et _delt ikke_ arkitektur**. En delt arkitektur bruger uafhængige, selv noder, der har ingen enkelt punkt med konflikt (såsom delte tjenester eller lagerplads). Sådan et system kan skalere næsten på ubestemt tid i teorien. Mens en fuldt delt-fremgangsmåde ikke er generelt praktisk for de fleste programmer, kan det muligvis give mulighed for at designe for bedre skalerbarhed. For eksempel undgå brug af serversiden sessionstilstand, klienten forbindelse og datapartitionering er gode eksempler på bestræbelserne på en delt arkitektur.

## <a name="data-management"></a>Datastyring

- **Brug data partitionering**. Opdele dataene på tværs af flere databaser og databaseservere eller design program tilladelse til at bruge datalagring tjenester, der kan give partitionering transparent (som eksempler kan nævnes Azure SQL Database elastiske Database og Azure Table storage). Denne metode kan hjælpe med at maksimere ydeevnen og tillade nemmere skalering. Der er forskellige partitionering teknikker, såsom vandret, lodret, og funktionelle. Du kan bruge en kombination af disse at opnå maksimale benefit fra øget forespørgselsydelse enklere skalerbarhed mere fleksibel administration, og bedre tilgængelighed og så det svarer til typen af store til de data, den skal indeholde. Overvej også at bruge forskellige typer datalager for forskellige typer data, vælge de typer, der er baseret på hvor godt de er optimeret til bestemte typer data. Dette kan omfatte bruger tabellagring, en dokument-database eller en kolonne familie datalager, i stedet for, eller så godt som en relationel database. Du kan finde yderligere oplysninger finder [Data leverandør vejledning](best-practices-data-partitioning.md).
- **Design til eventuel konsistens**. Eventuel konsistens forbedrer skalerbarhed ved at reducere eller fjerne den tid, der er behov for at synkronisere relaterede data opdelt på tværs af flere lagre. Omkostninger er, at dataene ikke er altid ensartet, når den er blevet læst, og nogle skrive handlinger kan medføre konflikter. Eventuel konsistens er velegnet til situationer, hvor de samme data ofte læser men skrevet sjældent. Du kan finde flere oplysninger [Data konsistens grundlæggende](https://msdn.microsoft.com/library/dn589800.aspx).
- **Reducere chatty interaktioner mellem komponenter og -tjenester**. Undgå at designe interaktioner, hvor et program er påkrævet til at foretage flere opkald til en tjeneste (hver især returnerer en lille mængde data), i stedet for et enkelt opkald, der kan returnere data. Hvor det er muligt, kan du kombinere flere relaterede handlinger i en enkelt anmodning, når opkaldet er til en tjeneste eller komponent, der har en chatanmodning ventetid. Det gør det nemmere at overvåge ydeevnen og optimere komplekse handlinger. For eksempel bruge lagrede procedurer i databaser til at omfatter kompleks logik, og du reducere antallet af trafik og ressource låsning.
- Du kan **bruge køer for at udjævne indlæsning af høj overførselshastighed data skriver**. Skader i krav om en tjeneste kan overvælde pågældende tjeneste og medføre stigende fejl. For at undgå dette, skal du overvejer at implementere [kø-baserede Indlæs udjævning mønster](https://msdn.microsoft.com/library/dn589783.aspx). Brug en kø, der fungerer som en bufferen mellem en opgave og en tjeneste, som det aktiverer. Dette kan udjævne forbigående stor belastning, der ellers kan medføre tjenesten mislykkes eller opgave udløber.
- **Minimer belastning på datalager**. Datalager er ofte et behandling flaskehals, en ressource, som dyrt og ofte ikke nemt at skalere ud. Hvor det er muligt, fjerne logik (såsom behandling af XML-dokumenter eller JSON objekter) fra datalager, og Udfør behandling i programmet. For eksempel i stedet for at overføre XML til databasen (andre end som en uigennemsigtig streng for lagerplads), sekventielt eller deserialisere XML inden for programlag og sende dem i en formular, der er indbygget i datalageret. Det er typisk meget nemmere at skalere ud af programmet end datalager, så skal du forsøge at gøre så meget af Beregn-intensivt behandling som muligt i programmet.
- **Minimer mængden af data er hentet**. Hent kun de data, du skal bruge ved at angive kolonner og bruge kriterier til at markere rækker. Gøre brug af tabel værdi parametre og de relevante isolationsniveau. Brug mekanismer som enhed mærker for at undgå unødvendig hentning af data.
- **Aggressivt bruger cachelagring**. Brug cachelagring, når det er muligt at reducere belastningen på ressourcer og -tjenester, oprette eller levere data. Cachelagring er typisk egnet til data, der er relativt statiske eller, der kræver betydelige behandling til at hente. Cachelagring skal udføres på alle niveauer, hvor det er relevant i hvert lag af programmet, herunder data access og bruger interface generering af. Du kan finde yderligere oplysninger finder [Cachelagring vejledning](best-practices-caching.md).
- **Håndtere datavækst og opbevaring**. Mængden data, der gemmes af et program vokser over tid. Denne vækst øges lagerplads omkostninger og øge ventetid, når adgang til dataene, som påvirker programmet overførselshastighed og ydeevne. Det kan være muligt at arkivere nogle af de gamle data, der ikke længere åbnes med jævne mellemrum eller flytte data, der sjældent opnås adgang til længerevarende opbevaring, der er mere effektivt, omkostninger, selvom access ventetid er højere.
- **Optimere overføre dataobjekter (DTOs) ved hjælp af en effektiv binært format**. DTOs overføres mellem lag i et program mange gange. Minimere størrelsen reducerer belastning på ressourcer og netværket. Dog saldo sparer med spild af dataene konverteres til det ønskede format på hver placering, hvor det bruges. Indføre et format, der indeholder den maksimale interoperabilitet til at aktivere nemt genbrug af en komponent.
- **Angive cache-styring**. Designe og konfigurere programmet til at bruge outputcachelagring eller fragmentere cachelagring, hvor det er muligt at minimere behandling Indlæs.
- **Aktivere cachen på klienten**. Webprogrammer skal aktivere cacheindstillinger på det indhold, der kan gemmes i cache. Dette er ofte deaktiveret som standard. Konfigurere serveren til at levere den relevante cache kontrolelement sidehoveder for at aktivere cachelagring af indhold på proxyservere og klienter.
- **Brug Azure blob-lager og Azure indhold levering netværk til at reducere belastning af programmet**. Overvej at gemme statisk eller relativt statiske offentlige indhold, som billeder, ressourcer, scripts og typografiark, i blob-lager. Denne metode mindsker anvendelse af afkrydsningsfeltet Indlæs skyldes dynamisk oprettelse af dette indhold for hver enkelt anmodning. Desuden kan du overveje at bruge netværk til levering af indhold til lagring af dette indhold og levere til klienter. Brug af netværk til levering af indhold kan forbedre ydeevnen på klienten, da indholdet er leveret fra det geografisk nærmeste datacenter, der indeholder en netværk til levering af indhold cache. Du kan finde yderligere oplysninger finder [Indhold levering netværk vejledning](best-practices-cdn.md).
- **Optimer og finjustere SQL-forespørgsler og indeks**. Nogle T-SQL-sætninger eller konstruktioner kan få indflydelse på ydeevnen, der kan blive reduceret, ved at optimere koden i en lagret procedure. For eksempel undgå konvertering af **typen Dato/klokkeslæt** til en **varchar** før sammenlignes med en ordret **dato/klokkeslæt** -værdi. Brug dato/klokkeslæt sammenligning af funktioner i stedet. Manglende relevante indeks kan også gøre langsom udførelse af forespørgsel. Hvis du bruger en OR/tilknytning ramme, at forstå, hvordan det fungerer, og hvordan det kan påvirke ydeevnen af data access lag. Du kan finde flere oplysninger, se [Justering af forespørgsel](https://technet.microsoft.com/library/ms176005.aspx).
- **Overvej at deaktivere normalisere dataene**. Datanormalisering hjælper med at undgå overlapning og inkonsekvens. Dog medfører vedligeholde flere indeks, kontrollerer, om referentiel integritet, udføre flere adgang til små dele af data og deltage i tabeller for at samle dataene, der en omkostninger, der kan påvirke ydeevnen. Overvej, hvis nogle ekstra lagerplads lydstyrken og kopiering kan accepteres for at reducere belastningen på datalager. Overvej også, hvis programmet selve (som er typisk nemmere at skalere) kan anvendes af at overtage opgaver som at administrere referentiel integritet for at reducere belastningen på datalager. Du kan finde yderligere oplysninger finder [Data leverandør vejledning](https://github.com/mspnp/azure-guidance/blob/master/Data%20partitioning.md).

## <a name="service-implementation"></a>Implementering af
- **Brug asynkron opkald**. Bruge asynkron kode når det er muligt, når adgang til ressourcer eller tjenester, der kan være begrænset af i/o- eller netværksbåndbredde, eller som har en chatanmodning ventetid for at undgå låsning opkald tråd. Brug [Opgavebaseret asynkron mønster (tryk)](https://msdn.microsoft.com/library/hh873175.aspx)for at implementere asynkrone handlinger.
- **Undgå at låse ressourcer, og brug en optimistisk metode i stedet**. Aldrig Lås adgang til ressourcer som lagerplads eller andre tjenester, der har en chatanmodning ventetid, fordi dette er en primære årsager til dårlig ydeevne. Brug altid optimistisk metoder til administration af samtidige handlinger, som skriver for lagerplads. Brug funktioner i lagerplads lag til at administrere konflikter. I forbindelse med distribuerede programmer data muligvis kun til sidst ensartet.
- **Komprimere meget Komprimerbar data over lang ventetid, lav båndbredde netværk**. I fleste tilfælde i et webprogram er den største mængde data genereres af programmet og overføres via netværket HTTP-svar til klient-anmodninger. HTTP-komprimering kan reducere dette betydeligt, især til statisk indhold. Dette kan reducere omkostninger samt reducere belastning på netværket, selvom komprimere dynamisk indhold gælder en fractionally højere belastning på serveren. I andre og vigtigere generalized miljøerne, datakomprimering kan reducere mængden af data, der overføres og minimere filoverførsel tid og omkostninger, men komprimering og dekomprimering processerne påløber omkostninger. Komprimering bør som sådan kun bruges, når der er en påviselige gevinst i ydeevne. Andre serialisering metoder, såsom JSON eller binære kodning kan reducere datastørrelsen mens har mindre indvirkning på ydeevne, mens XML sandsynligvis at øge den.
- **Minimer den tid, forbindelser og ressourcer, der er i brug**. Vedligeholde forbindelser og ressourcer kun til, så længe du skal bruge dem. Åbn eksempelvis forbindelser så sent som muligt, og give dem tilladelse til returneres til grupperingen af forbindelser så tidligt som muligt. Erhverv ressourcer så sent som muligt, og sælge dem så tidligt som muligt.
- **Minimer antallet af forbindelser påkrævet**. Forbindelser til opfanger ressourcer. Begrænse det tal, der er nødvendige, og Sørg for, at eksisterende forbindelser igen, når det er muligt. For eksempel, når du har udført godkendelse, bruge repræsentation hvor det er relevant at køre kode som en bestemt identitet. Dette kan hjælpe med at udnytte bedste grupperingen af forbindelser ved at genbruge forbindelser.

    > [AZURE.NOTE]: APIs for some services automatically reuse connections, provided service-specific guidelines are followed. It's important that you understand the conditions that enable connection reuse for each service that your application uses.

- **Sende anmodninger i batches til optimere netværk**. Sende og læse meddelelser i kladder, når du åbner en kø, og udføre flere læser eller skriver som en gruppe, når du åbner lagerplads eller en cache. Dette kan hjælpe med at maksimere effektivitet af tjenester og data forretninger ved at reducere antallet af kald på tværs af netværket.
- **Undgå et krav til at gemme serversiden sessionstilstand** hvor det er muligt. Staten serversiden sessionsstyring kræver typisk klienten forbindelse (som hver enkelt anmodning er, routing til den samme server-forekomst), der har indflydelse på systemet evne til at skalere. Ideelt set bør du udformer klienter mulighed for at være i en tilstand i forhold til de servere, de bruger. Men hvis programmet skal opretholde sessionstilstand, gemme følsomme data eller store datamængder-klient i en fordelt serversiden cache, der kan få adgang til alle forekomster af programmet.
- **Optimer tabel lagerplads skemaer**. Når du bruger tabel butikker, der kræver tabel- og kolonnenavne skal overføres og behandles med alle de forespørgsler, som Azure-tabellager, kan du overveje at bruge kortere navne til at reducere denne omkostninger. Dog ikke gå på kompromis læsbarhed eller administration ved hjælp af alt for kompakt navne.
- **Brug den opgave parallelle bibliotek (TPL) til at udføre asynkrone handlinger**. TPL gør det nemt at skrive asynkron kode, som udfører jeg/O-bundne handlinger. Brug _ConfigureAwait(false)_ , når det er muligt at fjerne afhængighed af en fortsættelse på en bestemt synkroniseringskontekst. Dette mindsker risikoen for tråd baglås til virkelighed.
- **Opret Ressourceafhængigheder under installation eller på Start af programmet**. Undgå gentagne kald til metoder, der tester eksistensen af en ressource og derefter oprette ressourcen, hvis den ikke findes. (Metoder som _CloudTable.CreateIfNotExists_ og _CloudQueue.CreateIfNotExists_ i biblioteket Azure lagerplads klient Følg dette mønster). Disse metoder kan angive betydelige omkostninger, hvis de aktiveres før hver adgang til en lagerplads tabel eller en lagerplads kø. I stedet:
 - Oprette de krævede ressourcer, når programmet er installeret, eller når det første gang starter (et enkelt opkald til _CreateIfNotExists_ for hver ressource i startkoden for en web eller arbejder rolle er acceptable). Men Sørg for at håndtere undtagelser, der kan opstå, hvis din kode forsøger at få adgang til en ressource, der ikke findes. I disse situationer, skal du logge på undtagelse og muligvis besked en operator, at der mangler en ressource.
 - I nogle tilfælde kan være det relevant at oprette den manglende ressource som en del af den undtagelse, der håndterer kode. Men du skal træffe denne fremgangsmåde med forsigtighed, som ikke findes på ressourcen, kan være vejledende af fejlen programming (for eksempel en forkert stavede ressourcenavn) eller et andet problem med infrastruktur niveau.
- **Brug lette strukturer**. Vælg omhyggeligt API'er og rammer, du kan bruge til at minimere Ressourceforbrug, kørselstid og overordnede belastning på programmet. For eksempel ved hjælp af Web API til at håndtere serviceanmodninger kan reducere program-miljøet og øge udførelse af hastighed, men det muligvis ikke passer til avancerede scenarier, hvor de yderligere funktioner i Windows Communication Foundation er påkrævet.
- **Overvej at minimere antallet af tjenestekonti**. For eksempel bruge en bestemt konto for at få adgang til ressourcer eller tjenester, der er angivet en grænse på forbindelser, eller Udfør bedre hvor færre forbindelser vedligeholdes. Denne metode er fælles for tjenester som databaser, men det kan påvirke muligheden for at overvåge præcist forskellige handlinger på grund af repræsentation af den oprindelige bruger.
- **Udføre ydeevne profiler og test af belastning** under udvikling, som en del af Testrutiner og før den endelige version for at sikre, at programmet udfører og ubalance efter behov. Denne test skal udføres i den samme type som hardware som fremstilling platform og med de samme typer og antal af data og bruger indlæses som det kan støde på i fremstilling. Du kan finde flere oplysninger, se [test af ydeevnen for en skybaseret tjeneste](vs-azure-tools-performance-profiling-cloud-services.md).
